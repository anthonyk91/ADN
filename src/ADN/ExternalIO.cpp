#include "ADN.h"
#include "ExternalIO.h"
#include "ParameterParser.h" // in Utils library- parses parameters from file
#include "logger.h"
#include "CTokenizer.h"
#include <sys/types.h>
#include <unistd.h>
#include "boost/program_options.hpp"

namespace adn {
using namespace logger;

// replaced by tag generated by cvs
#define COMPILED_VERSION "$LastChangedRevision: 1063 $ $LastChangedDate: 2014-11-27 22:35:45 +1100 (Thu, 27 Nov 2014) $"

ExternalIO::ExternalIO()
{
	_stdoutRec = new LogRecorder(&cout, LOGGER_GENERAL_ID, L_NOTSET, H_NOTSET, true);
    _stderrRec = new LogRecorder(&cerr, LOGGER_ERROR_ID, L_NOTSET, H_NOTSET, true);
	Logger::addRecorder(*_stdoutRec);
	Logger::addRecorder(*_stderrRec);
	_showpid = false;
}

ExternalIO::~ExternalIO()
{
}

#define DEFPREDCHANNEL "22"
#define DEFMODELFILE "model"
bool ExternalIO::readCommandLine(int argc, char* argv[]) 
{
   namespace po = boost::program_options;

   bool chpath = true;
   string a = "abc" "def" "g";

   // define command line options
   po::options_description desc("Options");
   desc.add_options()
			("script-file,s", po::value<string>(), "script file")
			("script-stdin,i", "read script from stdin")
			("seed-value,n", po::value<int>(), "random number seed")
			("version,v", "show version")
			("train-file,t", po::value<string>(), "load training file")
			("predict-file,r", po::value<string>(), "load prediction file")
			("format,f", po::value<string>(), "file format (arff (def) or csv)")
			("minutes,m", po::value<string>(), "training time (mins)")
			("model,d", po::value<string>(), "load model")
			("write-model,w", po::value<string>(), "write model")
			("output,o", po::value<string>(), "prediction output")
			("showpid,p", "add PID to output")
    ;

    po::variables_map vm;
    try {
    	po::store(po::parse_command_line(argc, argv, desc), vm);

    	/** --help option */
		if (vm.count("help"))
		{
		std::cout << "ADN learner:" << endl
				  << desc << std::endl;
		return true;
		}

        po::notify(vm); // throws on error, so do after help in case
                          // there are any problems
    } catch(po::error& e) {
    	std::cout << e.what() << endl
    		<< desc << endl;
    	return false;
	}

    if (argc == 1) {
        // problem reading command line
    	std::cout << desc << endl;
        return false;
    }
    
    // interpret parameters
    unsigned long int randSeed;
    if (vm.count("seed-value")) {
    	randSeed = vm["seed-value"].as<int>();
    } else {
    	randSeed = time(NULL);
    	randSeed *= getpid();
    }
    _SeedRand(randSeed);
    
	// show version info
    if (vm.count("version")) {
    	trace("version: %s\n", COMPILED_VERSION);
    	return false;
    }

	// attach PID
    if (vm.count("showpid")) _showpid = true;

    // attach input, read from script file into data store
    string scriptfile;
    bool scriptReadOk = false;
    if (vm.count("script-file")) {
    	scriptfile = vm["script-file"].as<string>();
    	scriptReadOk = _parameterData.parseFile(scriptfile);
        if (! scriptReadOk) error("could not read file: %s", scriptfile.c_str());
    }

    // read from stdid in specified
    if (vm.count("script-stdin")) _parameterData.parseStream(cin);

    // check if file format specified
    string readCommand = "loadARFF";
    if (vm.count("format")) {
    	if (vm["format"].as<string>() == "csv") readCommand = "loadCSV";
    	else if (vm["format"].as<string>() == "arff") readCommand = "loadARFF";
    }
	// record training file if given.  add load command before read model command
    // so get data types
    if (vm.count("train-file")) {
    	// add load command to action list
    	stringstream ss;
    	ss << readCommand << " " << vm["train-file"].as<string>() << " " << trainSet;
    	_parameterData.addMulti(MKEY_ACTIONCMD, ss.str());
    }
	// record prediction file if given
    if (vm.count("predict-file")) {
    	// add load command to action list
    	stringstream ss;
    	ss << readCommand << " " << vm["predict-file"].as<string>() << " " << predSet;
    	_parameterData.addMulti(MKEY_ACTIONCMD, ss.str());
    }
    // add load model action if given
    if (vm.count("model")) {
    	// add load command to action list
    	stringstream ss;
    	ss << ACT_READMODEL << " " << vm["model"].as<string>();
    	_parameterData.addMulti(MKEY_ACTIONCMD, ss.str());
    }

	// add run command if training file was given
    if (vm.count("train-file")) {
    	_parameterData.addMulti(MKEY_ACTIONCMD, ACT_RUN);

    	string modelFile = DEFMODELFILE;
    	if (vm.count("write-model")) {
    		modelFile = vm["write-model"].as<string>();
    	}

    	// and output model afterwards
    	stringstream ss;
    	ss << ACT_WRITEMODEL << " " << modelFile;
    	_parameterData.addMulti(MKEY_ACTIONCMD, ss.str());

    	chpath = false;
    }

	// add evaluate command if prediction file given
    if (vm.count("predict-file")) {
    	_parameterData.addMulti(MKEY_ACTIONCMD, ACT_EVALUATE);
    }

    if (vm.count("output")) {
    	// if prediction channel not given, specify
    	string predChannel;
    	if (_parameterData.keyDefined(IKEY_PREDCHANNEL)) {
    		predChannel = _parameterData.grab(IKEY_PREDCHANNEL);
    	} else {
    		_parameterData.setValue(IKEY_PREDCHANNEL, DEFPREDCHANNEL);
    		predChannel = DEFPREDCHANNEL;
    	}
		// set output file definition
    	stringstream ss;
    	ss << "file " << vm["output"].as<string>() << " " << predChannel;
    	_parameterData.addMulti(MKEY_OUTPUTLIST, ss.str());

    	// set definition for file recorder with given name on predChannel
    	chpath = false; // stay in same dir
    }

    if (vm.count("minutes")) {
    	_parameterData.setValue(IKEY_TRAINTIME, vm["minutes"].as<string>());
    }

	// set up output streams
	initialiseOutput(chpath);

	// dump settings into general output stream
    _lss << "==== settings:" << endl;
    _lss << "binary identifier tag: " << COMPILED_VERSION << endl; 
    if (scriptReadOk) _lss << "script file read: " << scriptfile << endl;
    _lss << "random number seed=" << randSeed << endl;
    log();

    _lss << "==== parameter stream read:" << endl;
	_lss << _parameterData.getStreamRead() << endl;
	_lss << "==== (end parameter stream read)" << endl;
	_lss << "==== parameter defs:" << endl;
	_parameterData.getAllDefs(_lss);
	_lss << "==== (end parameter defs)" << endl;
	_lss << endl;
	log();
	
	return true;
}

void ExternalIO::initialiseOutput(bool chpath) {
	using namespace boost::filesystem;
	
	// set up directory to write output to.  mkdir if not exists and chdir to it
	if (chpath) {
		string outputPath;
		_seekStr(outputPath, SKEY_RESULTPATH, "");

		// set up general output directory
		if (exists(outputPath)) {
			_Assert(is_directory(outputPath), ("invalid result path %s, not a directory\n", outputPath.c_str()));
			// path found
		} else {
			// attempt to create
			_Assert(create_directory(outputPath), ("could not create output path: %s\n", outputPath.c_str()));
		}
		chdir(outputPath.c_str());
	}
	
	// set up output directory for this run
	if (chpath) {
		string runPath;
		_seekStr(runPath, SKEY_RUNNAME, "");
		ostringstream os;
		os << runPath;
		if (_showpid) os << "_" << getpid();
		runPath = os.str();

		if (exists(runPath)) {
			_Assert(is_directory(runPath), ("invalid result path %s, not a directory\n", runPath.c_str()));
			// path found
		} else {
			// attempt to create
			_Assert(create_directory(runPath), ("could not create output path: %s\n", runPath.c_str()));
		}
		chdir(runPath.c_str());
	}	
	
	Logger& logInst = Logger::getLoggerInstance();
	
	// setup output to stdout (1) and stderr (2) by default
	vector<int> ch(1);
	ch[0] = 1;
	logInst.setChannel(1, ACTIVE);
	_stdoutRec->setChannels(ch);
	ch[0] = 2;
	logInst.setChannel(2, ACTIVE);
	_stderrRec->setChannels(ch);

	// set up external output (specific files & streams)
	ParameterParser::Listtype outputList = ParameterParser::getInstance().getList(MKEY_OUTPUTLIST);
	vector<string> tokens;
	while(! outputList.empty()) {
		// split to: format key channel [channel..]
		string thisString = outputList.front();
		outputList.pop_front();
		
		CTokenizer<>::tokenize(tokens, thisString);
		if (tokens.size() < 3) continue;
		
		vector<int> channels;
		int size = tokens.size();
		for (int i=2; i<size; i++) {
			int thisChannel = atoi(tokens[i].c_str());
			channels.push_back(thisChannel);
			logInst.setChannel(thisChannel, ACTIVE);			
		}

		LogRecorder* rec = NULL;
		if (! tokens[0].compare(MSUBKEY_OUTPUTLIST_FILETYPE)) {
			rec = new FileRecorder(tokens[1], channels);
			//TODO: add support for recording record level (eg debug, trace etc)
		} else if (! tokens[0].compare(MSUBKEY_OUTPUTLIST_STREAMTYPE)) {
			// standard stream, simply update settings of existing stream
			// objects.
			if (! tokens[1].compare(MSUBKEY_OUTPUTLIST_STDOUT)) {
				_stdoutRec->setChannels(channels);
			} else if (! tokens[1].compare(MSUBKEY_OUTPUTLIST_STDERR)) {
				_stderrRec->setChannels(channels);
			}
		}
		
		if (rec != NULL) logInst.addRecorder(*rec);
	}	

    // set up datestamped channels
	string datestampList = _findStr(SKEY_DATESTAMPLIST);
	CTokenizer<>::tokenize(tokens, datestampList);
	vector<string>::iterator iter;
	_foreach(tokens, iter) {
		string thisStr = *iter;
		if (thisStr.empty()) continue;
		int channel = atoi(thisStr.c_str());
		logInst.setChannel(channel, DATESTAMP);
	}

	// set ignore levels of various channels
	ParameterParser::Listtype levelList = ParameterParser::getInstance().getList(MKEY_SCREENLEVELLIST);
	while(! levelList.empty()) {
		string thisLevelSettings = levelList.front();
		levelList.pop_front();
		
		if (thisLevelSettings.empty()) continue;
		CTokenizer<>::tokenize(tokens, thisLevelSettings);
		vector<string>::iterator iter;
		
		// tokens are: channel ignoreLevel 
		if (tokens.size() != 2) {
			warn("invalid channelScreenLevel settings: %s\n", thisLevelSettings.c_str());
			continue;
		}
		
		int channel = atoi(tokens[0].c_str());
		log_level screenValue = L_NOTSET;
		switch(atoi(tokens[1].c_str())) {
		case 1: screenValue = DEBUG; break;
		case 2: screenValue = TRACE; break;
		case 3: screenValue = NOTICE; break;
		case 4: screenValue = WARNING; break;
		case 5: screenValue = ERROR; break;
		case 6: screenValue = CRITICAL; break;
		}
		
		if (screenValue != L_NOTSET) logInst.setChannelScreenLevel(channel, screenValue);	
	}
	
}

} // namespace 

